<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>大学フロアマップ表示（GeoJSON + Leaflet + 部屋ハイライト）</title>
    <!-- Leaflet の CSS を読み込む -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
      /* ページ全体の余白をリセット */
      body,
      html {
        margin: 0;
        padding: 0;
        height: 100%;
      }
      /* 地図表示領域を全画面に */
      #map {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <!-- 地図を描画するための div -->
    <div id="map"></div>

    <!-- Leaflet の JS を読み込む -->
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
      // ──────────────────────────────
      // 1. GeoJSON データ定義
      //    先ほどの回答で示した「大学のフロアマップ」を GeoJSON フォーマットで定義します。
      //    必要があれば座標を実測値に合わせて修正してください。
      // ──────────────────────────────
const floorMapData = {
  type: "FeatureCollection",
  crs: { type: "name", properties: { name: "CRS:PIXEL" } },
  features: [
      {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[781,91],[777,380],[84,389],[84,448],[364,448],[366,837],[84,837],[84,929],[776,932],[776,1431],[839,1431],[841,91]]] },
      properties: { id: "R073", name: "Room073", type: "room", area: 354190 }
    },
    /* ─── 以下、各部屋を矩形化 ─── */
    {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[846,1289],[1088,1289],[1088,1436],[846,1436],[846,1289]]] },
      properties: { id: "R004", name: "Room004", type: "room", area: 34869 }
    },
    {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[846,989],[1092,989],[1092,1283],[846,1283],[846,989]]] },
      properties: { id: "R008", name: "Room008", type: "room", area: 71467 }
    },
    {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[649,938],[769,938],[769,1222],[649,1222],[649,938]]] },
      properties: { id: "R010", name: "Room010", type: "room", area: 33861 }
    },
    {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[459,938],[643,938],[643,1219],[459,1219],[459,938]]] },
      properties: { id: "R011", name: "Room011", type: "room", area: 51433 }
    },
    {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[209,938],[453,938],[453,1217],[209,1217],[209,938]]] },
      properties: { id: "R012", name: "Room012", type: "room", area: 67544 }
    },
    {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[84,936],[203,936],[203,1215],[84,1215],[84,936]]] },
      properties: { id: "R016", name: "Room016", type: "room", area: 33388 }
    },
    {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[846,692],[1093,692],[1093,985],[846,985],[846,692]]] },
      properties: { id: "R022", name: "Room022", type: "room", area: 72050 }
    },
    {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[847,541],[1094,541],[1094,685],[847,685],[847,541]]] },
      properties: { id: "R050", name: "Room050", type: "room", area: 35691 }
    },
    {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[427,455],[776,455],[776,871],[427,871],[427,455]]] },
      properties: { id: "R056", name: "Room056", type: "room", area: 94347 }
    },
    {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[84,580],[358,580],[358,830],[84,830],[84,580]]] },
      properties: { id: "R058", name: "Room057", type: "room", area: 73746 }
    },
    {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[84,454],[358,454],[358,574],[84,574],[84,454]]] },
      properties: { id: "R058", name: "Room058", type: "room", area: 73746 }
    },

    {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[848,390],[1093,390],[1093,534],[848,534],[848,390]]] },
      properties: { id: "R060", name: "Room060", type: "room", area: 35243 }
    },
    {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[84,101],[205,101],[205,380],[84,380],[84,101]]] },
      properties: { id: "R063", name: "Room063", type: "room", area: 33763 }
    },
    {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[211,97],[453,97],[453,379],[211,379],[211,97]]] },
      properties: { id: "R066", name: "Room066", type: "room", area: 67497 }
    },
    {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[460,94],[645,94],[645,377],[460,377],[460,94]]] },
      properties: { id: "R069", name: "Room069", type: "room", area: 51855 }
    },
    /* ─── R073 は元形状を保持 ─── */
    /* ─── 続き ─── */
    {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[652,91],[772,91],[772,374],[652,374],[652,91]]] },
      properties: { id: "R074", name: "Room074", type: "room", area: 33729 }
    },
    {
      type: "Feature",
      geometry: { type: "Polygon", coordinates: [[[849,87],[1092,87],[1092,385],[849,385],[849,87]]] },
      properties: { id: "R075", name: "Room075", type: "room", area: 72292 }
    }
  ]
};


      // ──────────────────────────────
      // 2. Leaflet マップを初期化
      //    CRS.Simple を使って「緯度経度ではなく任意の平面座標」を扱います。
      // ──────────────────────────────
      const map = L.map("map", {
        crs: L.CRS.Simple,
        attributionControl: false,
        minZoom: -2,
      });

      // ──────────────────────────────
      // 3. GeoJSON を読み込んでスタイル・ポップアップを設定
      // ──────────────────────────────
      //    各フィーチャの type に応じて初期スタイルを決定
      function getInitialStyle(feature) {
        switch (feature.properties.type) {
          case "room":
            return {
              color: "#333333",
              weight: 1,
              fillColor: "#cccccc",
              fillOpacity: 0.3,
            };
          case "hall":
            return {
              color: "#555555",
              weight: 1,
              fillColor: "#dddddd",
              fillOpacity: 0.2,
            };
          case "corridor":
            return {
              color: "#999999",
              weight: 1,
              fillColor: "#eeeeee",
              fillOpacity: 0.1,
            };
          case "facility":
            return {
              color: "#b22222",
              weight: 1,
              fillColor: "#f4a7a7",
              fillOpacity: 0.4,
            };
          default:
            return {
              color: "#000000",
              weight: 1,
              fillColor: "#ffffff",
              fillOpacity: 0.1,
            };
        }
      }

      let highlightedLayer = null; // 現在ハイライト中の L.Layer を保持

      const floorLayer = L.geoJSON(floorMapData, {
        style: getInitialStyle,
        onEachFeature: (feature, layer) => {
          // ポップアップに部屋名や設備名を表示
          if (feature.properties.name) {
            layer.bindPopup(
              `<b>${feature.properties.name}</b><br>Type: ${feature.properties.type}`
            );
          }
        },
      }).addTo(map);

      // ──────────────────────────────
      // 4. 地図の表示範囲を GeoJSON の境界に合わせて調整
      // ──────────────────────────────
      const bounds = floorLayer.getBounds();
      map.fitBounds(bounds, { padding: [20, 20] });

      // ──────────────────────────────
      // 5. クリックした地点がどのポリゴン（部屋）に含まれるかを判定し、ハイライトする
      //
      //    ここでは「地図上をクリック」したときの例ですが、実際は
      //    屋内測位サーバーから返ってくる (x,y) 座標 を e.latlng のように使えば同じ処理が可能です。
      // ──────────────────────────────
      map.on("click", function (e) {
        // e.latlng は CRS.Simple なので [lat=y, lng=x] の順序で渡される
        // 例) e.latlng = L.LatLng(200, 350) ← これは (x=350px, y=200px) に相当

        let foundLayer = null;

        // すべてのポリゴン（レイヤー）を走査して、クリック地点を含むものを探す
        floorLayer.eachLayer((layer) => {
          if (!(layer instanceof L.Polygon)) return;

          // layer.getBounds() はポリゴンを包含する最小矩形を返す
          // 今回のサンプルでは矩形を使って部屋を定義しているので
          // getBounds().contains(e.latlng) 判定で十分です。
          if (layer.getBounds().contains(e.latlng)) {
            foundLayer = layer;
          }
        });

        // もし既にハイライト中のレイヤーがあれば、元のスタイルに戻す
        if (highlightedLayer) {
          const origFeat = highlightedLayer.feature;
          highlightedLayer.setStyle(getInitialStyle(origFeat));
          highlightedLayer = null;
        }

        // クリック地点が含まれるポリゴンが見つかったら……
        if (foundLayer) {
          // ポリゴンのスタイルを変えて、ハイライト表示
          foundLayer.setStyle({
            fillColor: "#ffff00",
            fillOpacity: 0.6,
            color: "#ff0000",
            weight: 2,
          });
          highlightedLayer = foundLayer;

          // ポップアップも表示しておく（任意）
          const props = foundLayer.feature.properties;
          foundLayer
            .bindPopup(
              `<b>現在地と推定された部屋:</b><br>${props.name} (${props.id})`
            )
            .openPopup();
        }
      });

      // ──────────────────────────────
      // 6. （外部座標を使う例）任意の (x, y) 座標から部屋をハイライトする関数
      //
      //    例えば、屋内測位サーバーから { x: 350, y: 200 } のような平面座標を受け取ったら
      //    次の `highlightByXY(350, 200)` を呼び出すだけで同じ動作になります。
      // ──────────────────────────────
      function highlightByXY(x, y) {
        // Leaflet の CRS.Simple では [lat=y, lng=x] の順序
        const clickedLatLng = L.latLng(y, x);

        let found = null;
        floorLayer.eachLayer((layer) => {
          if (!(layer instanceof L.Polygon)) return;
          if (layer.getBounds().contains(clickedLatLng)) {
            found = layer;
          }
        });

        if (highlightedLayer) {
          const prevFeat = highlightedLayer.feature;
          highlightedLayer.setStyle(getInitialStyle(prevFeat));
          highlightedLayer = null;
        }

        if (found) {
          found.setStyle({
            fillColor: "#ffff00",
            fillOpacity: 0.6,
            color: "#ff0000",
            weight: 2,
          });
          highlightedLayer = found;
          const p = found.feature.properties;
          found
            .bindPopup(`<b>現在地と推定された部屋:</b><br>${p.name} (${p.id})`)
            .openPopup();
        }
      }

      // ──────────────────────────────
      // 7. テスト例：画面読み込みから 2 秒後に (x=350, y=200) をハイライトしてみる
      //    （実際は不要ですが、動作確認用サンプルとして）
      // ──────────────────────────────
      setTimeout(() => {
        highlightByXY(350, 200);
      }, 1000);
    </script>
  </body>
</html>
